//=======================================================================================
//
// this files contains simple examples of selected STL and C++11 functions
// Copyright XMementoIT Limited
// Author: Damian Ziobro 
//
// useful materials for below examples:
//   - C++ Standard Library - The tutorial and the reference - book 
//   - C++11 new features description - http://en.wikipedia.org/wiki/C%2B%2B11 
//   - lambda functions explanation: http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B
//   - unique_ptr vs auto_ptr: http://stackoverflow.com/questions/13481579/unique-ptr-vs-auto-ptr
//
//  WARNING!!! Search mark 'MARK' for easier moving between perticular featuers
//=======================================================================================

#include <iostream>
#include <memory> //required for unique_ptr
#include <vector>
#include <map>
#include <algorithm>
#include <iterator> //required for ostream_iterator
using namespace std;


//MARK: STRONGLY_TYPED_ENUMERATIONS
enum class Colors {
    Red,
    Green,
    Blue = 100,
    Yellow, //comparing Colors::Yellow == 101 is not available (compilation error), see enumerationsTest()
};


//MARK: EXPLICIT_DEFAULT_AND_DELETE 
//By default compiler provides us four generated functions (if they are not
//created explicitely): default constructor, copy constructor, copy assignment
//operator and destructor. EXPLICIT_DEFAULT_AND_DELETE feature of C++11 allows
//to explicitely make some constructor being default constructor as well as
//delete (switch off) some functions generated by default (ex. copy constructor)
class testClass {
public:
    testClass () = default;  // explicitely assigning default constructor
    testClass(const testClass&) = delete; //explicitely deleting copy constructor
    virtual ~testClass ();
};


struct testStruct {
    int testField;
};

class BaseClass {
public:
    BaseClass (string text){
        cout << "Single parameter constructor: " << text << endl;
        setText(text);
    }
    //MARK: CONSTRUCTORS_TOGETHER
    //using C++11 object construction improvements which allows using one
    //constructor in conjuction to another one without create auxillary funtion
    //In C++03 it was impossible to invoke one constructor into another one because
    //inside constructor construct object which was freeing at the end of
    //external constructor. There was needed to create additional function
    //init() for that. Below syntax allows to use two construtors together;
    BaseClass() : BaseClass("default") { 
        cout << "No parameter (default) constructor " << endl;
    }

    BaseClass(const BaseClass& baseClass) : text(baseClass.text){ cout << "Copy constructor" << endl; } //copy constructor

    //MARK: MOVE_CONSTRUCTOR
    BaseClass(BaseClass&& baseClass) : text(baseClass.text){ cout << "Move constructor" << endl; } // move constructor

    BaseClass& operator=(BaseClass&& baseClass){
        cout << "Move assignment operator" << endl;
        std::swap(text, baseClass.text);
        return *this;
    }

    //MARK: VIRTUAL_DESTRUCTOR
    //using virtual destructor to allow late binding of destructor for 
    //classes which will inherit from this class (it allows polimorphism)
    virtual ~BaseClass (){
        cout << "Destruct class: " << text << endl;
    }

    void setText(string text){
        this->text = text;
    }

    string getText(){
        return text;
    }

private:
    //MARK: DECLARATION_WITH_DEFINITION
    string text = "basic"; //this definition is allowable in C++11 (not allowable in C++03)
};

/* ======= Function ==================================================
 *   Name: testFunction
 *   Description: passing function as argument of other function
 * =================================================================== 
 */

//MARK: STD::FUNCTION_PASSING
void testFunction(std::function<void(void)> func, string testName){
    cout << "=== START ====================================================================" << endl;
    cout << "=== " << testName << " test ================================" << endl;
    func();
    cout << "=== END====================================================================" << endl << endl;
}

/* ======= Function ==================================================
 *   Name: uniquePtrTest
 *   Description: test of unique pointer function
 * =================================================================== 
 */
//MARK: UNIQUE_PTR_TEST
void uniquePtrTest(){

    //==> UNIQUE_PTR_USAGE
    unique_ptr<BaseClass> testAutoPtr(new BaseClass("AAA"));
    unique_ptr<BaseClass> secondAutoPtr(new BaseClass("BBB"));
    secondAutoPtr = std::move(testAutoPtr); //using std::move to transfer ownership
                                            // unique_ptr does not allow other
                                            // ownership transfer

    //cout << "Test text testAutoPtr: " << (*testAutoPtr).getText() << endl;
    cout << "Test text secondAutoPtr: " << (*secondAutoPtr).getText() << endl;

    //see unique_ptr vs auto_ptr: http://stackoverflow.com/questions/13481579/unique-ptr-vs-auto-ptr
}

/* ======= Function ==================================================
 *   Name: vectorTest
 *   Description: Test of vector
 * =================================================================== 
 */
//MARK: VECTOR_TEST
void vectorTest()
{
    //test vector using unique_ptr (C++11) to that vector
    unique_ptr<vector<int>> testVector(new vector<int>());
    //filling vector
    for (int i = 0; i < 3; i++) {
       testVector->push_back(i*i); 
    }

    //MARK: AUTO_TYPE
    //printing vector elements using auto iterator - C++11
    int i = 0;
    for(auto iter=testVector->begin(); iter != testVector->end(); iter++) {
        cout << "Vector[" << i << "] = " << *iter << endl;
        i++;
    }

    //MARK: RANGE_BASED_FOR_LOOP
    //printing vector elements using foreach - C++11 
    for (auto &iter : *testVector){
        cout << "iter: " << iter << endl;
    }

    //MARK: PRINTING_VECTOR_USING_STREAM_ITERATOR 
    copy(testVector->begin(), testVector->end(), ostream_iterator<int>(cout, " \n"));

}

/* ======= Function ==================================================
 *   Name: mapTest
 *   Description: test of map structure
 * =================================================================== 
 */

//MARK: MAP_TEST
void mapTest(){
    map<int,string> testMap;

    for (int i = 47; i < 55; i++) {
        testMap.insert(make_pair(i,"ccc"));
    }

    //use auto type from C++11 to save time and space of writing iterator
    //use range-based for loop from C++11 to save 
    for (auto &iter : testMap){
        cout << "iter.first: " << iter.first << "; iter.second: " << iter.second  << endl;
    }
}

/* ======= Function ==================================================
 *   Name: lambdaFunctionsTest
 *   Description: Test of lambda functions in C++11
 * =================================================================== 
 */
void lambdaFunctionsTest(){
   vector<int> testVector;
    for (int i = 0; i <=5; i++) {
        testVector.push_back(i);
    }

    //MARK: LAMBDA_FUNCTIONS_USAGE
    //use lambda function to calculate sum of all vector elements
    int sum = 0;
    for_each(testVector.begin(), testVector.end(), [&sum](int x){sum+=x;});

    cout << "Sum of vector elements after using lambda function: " << sum << endl;
}


/* ======= Function ==================================================
 *   Name: constructionImprovementsInCpp11
 *   Description: 
 * =================================================================== 
 */
void constructionImprovementsInCpp11(){
    //testing default constructor of BaseClass which invokes other constructor, too 
    //see explenation in the body of class BaseClass (mark: CONSTRUCTORS_TOGETHER)        

    unique_ptr<BaseClass> testPtr(new BaseClass());
    cout << "Test text secondAutoPtr: " << (*testPtr).getText() << endl;

}

/* ======= Function ==================================================
 *   Name: enumerationsTest
 *   Description: Test of new enumerations classes 
 * =================================================================== 
 */
void enumerationsTest()
{
    Colors yellowColor = Colors::Yellow;
    //Colors yellowColor = 101;   //compilation error because of type safety enumeration from C++11
}


/* ======= Function ==================================================
 *   Name: sizeOfFormembersOfClassTest
 *   Description: Test sizeof operator working for members of structs or class (C++11)
 * =================================================================== 
 */
//MARK: SIZEOF_WITH_MEMBERS_OF_STRUCT_OR_CLASS
void sizeOfForMembersOfStructOrClassTest()
{
    int testFieldSize = sizeof(testStruct::testField);
    cout << "testFieldSize: " << testFieldSize << endl;
}


/* ======= Function ==================================================
 *   Name: tupleTest
 *   Description: test of C++11 tuples 
 * =================================================================== 
 */

//MARK: TUPLE_TYPES
void tupleTest()
{
    std::tuple<double, int, string> testTuple (1.1, 10, "Test");

    cout << "======> Tuple before modiciation" << endl;
    cout << "Tuple double value: " << std::get<0>(testTuple) << endl;
    cout << "Tuple int value: " << std::get<1>(testTuple) << endl;
    cout << "Tuple string value: " << std::get<2>(testTuple) << endl;

    //tuple modification 
    std::get<0>(testTuple) = 5.1;
    std::get<1>(testTuple) = 7;
    std::get<2>(testTuple) = "ModifiedTest";

    cout << "======> Tuple after modiciation" << endl;
    cout << "Tuple double value: " << std::get<0>(testTuple) << endl;
    cout << "Tuple int value: " << std::get<1>(testTuple) << endl;
    cout << "Tuple string value: " << std::get<2>(testTuple) << endl;

}

//this function can not be implemented alongside the same function having
//reference or rvalue reference parameter 

//void passString(string testString){
    //testString = testString + "_normal";
    //cout << "valuePassing: testString: " << testString << endl;
//}

void passString(string& testString){
    testString = testString + "_normal";
    cout << "referencePassing: testString: " << testString << endl;
}

void passString(string&& testString, int&& secondValue = 5){
    testString = testString+"_rvalue";
    cout << "rValueReferencePassing: testString: " << testString <<  "; secondValue: " << secondValue << endl;
}

//MARK: STD_INITIALIZER_LIST AND TEMPLATE
template <class T>
void printElementsFromInitializerList(std::initializer_list<T> values){
    cout << "Number of values in initializer_list: " << values.size() << endl;
    for(auto i = begin(values); i!=end(values); i++){
        cout << *i << endl;
    }
}

void initializerListTest(){

    //testing initialization list
    cout << " => Normal initialization list test: " << endl;
    printElementsFromInitializerList<int>({1,3,5,10});

    cout << " => Vector as initialization list: " << endl;
    vector<int> testVector = { 5, 7, 10, 20}; //we can do this because vector has initializer list implemented in C++11
    for(auto &i : testVector){
        cout << i << endl;
    }
}

/* ======= Function ==================================================
 *   Name: rvalueReferenceTest
 *   Description: Text of rvalue reference and move constructor
 * =================================================================== 
 */
//MARK: RVALUE_REFERENCE
void rvalueReferenceTest()
{
    BaseClass baseClass("aaa");

    cout << "creation: baseClass.text(): " << baseClass.getText() << endl;

    //passing by reference
    string lValueText = baseClass.getText();
    passString(lValueText);
    passString(baseClass.getText());

    cout << "after valuePassion: baseClass.text(): " << baseClass.getText() << endl;

    //passing by rvalue reference (baseClass.getText() is temporary)
    passString(baseClass.getText(), 6);

    cout << "after rValueReferencePassing: baseClass.text(): " << baseClass.getText() << endl;

}

/* ======= Function ==================================================
 *   Name: main 
 *   Description: main entry of program
 * =================================================================== 
 */

int main(int argc, const char *argv[])
{


    testFunction(uniquePtrTest, "unique_ptr");
    testFunction(vectorTest, "vector");
    testFunction(mapTest, "map");
    testFunction(lambdaFunctionsTest, "lambda functions");
    testFunction(constructionImprovementsInCpp11, "construction improvements");
    testFunction(enumerationsTest, "enumerationsTest");
    testFunction(sizeOfForMembersOfStructOrClassTest, "sizeOfForMembersOfStructoOrClassTest");
    testFunction(tupleTest, "tupleTest");
    testFunction(rvalueReferenceTest, "rvalueReferenceTest");
    testFunction(initializerListTest, "initializerListTest");

    return 0;
}
